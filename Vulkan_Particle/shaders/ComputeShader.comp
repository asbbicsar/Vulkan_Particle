#version 450

struct Particle {
    vec4 pos;
    vec4 vel;
};

layout (local_size_x = 256) in;

layout(std430, binding = 0) buffer PosIn {
    Particle particlesIn[];
};
layout(std430, binding = 1) buffer PosOut {
    Particle particlesOut[]; 
};

layout(push_constant) uniform PushConstants {
    float dt;
} pc;

float random(uint seed) {
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return float(seed) / 4294967296.0;
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= particlesIn.length()) return;

    //vec3 pos = vec3(particlesIn[i].pos.x, 0.0, particlesIn[i].pos.z);
    vec3 pos = particlesIn[i].pos.xyz;
    vec3 vel = particlesIn[i].vel.xyz;

    float distSq = dot(pos, pos);
    float dist = sqrt(distSq);
    vec3 dirToCenter = -pos / (dist + 0.0001);

    float gravityStrength = 1.2;
    float softening = 0.05;
    vec3 attraction = dirToCenter * (gravityStrength / (distSq + softening));

    vec3 up = vec3(0.0, 1.0, 0.0);
    if (abs(dot(normalize(pos), up)) > 0.99) {
        pos.x += 0.01; // Y축에 너무 붙어있으면 살짝 옆으로 밈
    }
    vec3 tangent = normalize(cross(pos + vec3(0.1), up));
    vec3 rotation = tangent * (2.0 / (dist + 0.05));

    vec3 repulsion = -dirToCenter * exp(-dist * 5.0) * 10.0;

    vec3 acceleration = attraction + rotation + repulsion;
    //vec3 acceleration = attraction + repulsion;

    vel += acceleration * pc.dt;
    vel *= 0.995;
    pos += vel * pc.dt;

    if (dist < 0.1) {
        uint seed = i + uint(pc.dt * 1000.0);
        
        float phi = random(seed) * 2.0 * 3.141592;      // 0~1 사이 값
        float theta = random(seed + 1) * 3.141592;  // 다른 시드로 또 다른 값

        pos = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
        vel = vec3(0.0);
    }

    particlesOut[i].pos.xyz = pos;
    particlesOut[i].vel.xyz = vel;
    particlesOut[i].pos.w = length(vel);
}